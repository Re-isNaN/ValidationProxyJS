# Validation Proxy JS

## Introdu√ß√£o / Introduction
### üáßüá∑ Portugu√™s
Este projeto tem como objetivo a cria√ß√£o de uma ferramenta de valida√ß√£o utilizando o objeto Proxy em JavaScript. A ferramenta √© respons√°vel por validar dois campos essenciais: nome e idade de um usu√°rio.

As principais funcionalidades incluem:
1. **Valida√ß√£o de campos e exibi√ß√£o de erros ap√≥s o clique em um bot√£o**  
2. **Valida√ß√£o em tempo real utilizando Proxy, ap√≥s o evento inicial**

O projeto explora conceitos importantes de valida√ß√£o din√¢mica. Inicialmente, os campos s√£o validados apenas ap√≥s o clique no bot√£o. A partir desse momento, a valida√ß√£o passa a ser feita em tempo real, exibindo mensagens de erro logo abaixo de cada campo, conforme os valores forem sendo modificados.

### üåê English

This project aims to create a validation tool using the Proxy object in JavaScript. The tool is responsible for validating two essential fields: the user's name and age.

The main features include:

1. **Field validation and error display triggered by a button click**
2. **Real-time validation using Proxy, after the initial event**

The project explores key concepts of dynamic validation. Initially, fields are only validated after the button is clicked. From that point on, validation is performed in real time, showing error messages directly beneath each field as their values are updated.

---

## üß† Tecnologias e Abordagem
- **Proxy**: Objeto do JavaScript que permite criar um intermedi√°rio (proxy) para outro objeto, interceptando e customizando opera√ß√µes fundamentais como leitura, escrita e dele√ß√£o de propriedades.
- **Padr√£o de Projeto Builder**: padr√£o utilizado para construir objetos complexos de forma clara e flex√≠vel, separando a constru√ß√£o da representa√ß√£o. No contexto deste projeto, √© aplicado para organizar a cria√ß√£o das regras de valida√ß√£o de maneira escal√°vel.
- **Padr√£o de Projeto Factory**: Utilizado de forma complementar para separar a l√≥gica de valida√ß√£o do Controller da manipula√ß√£o da View, promovendo uma arquitetura mais organizada. Apesar disso, n√£o √© o foco principal do projeto.
- **JavaScript**: para a estrutura geral do projeto.

## üß† Technologies and Approach

- **Proxy**: A JavaScript object that allows the creation of an intermediary (proxy) for another object, intercepting and customizing fundamental operations like reading, writing, and deleting properties.
- **Builder Design Pattern**: A pattern used to construct complex objects in a clear and flexible way, separating the construction from the representation. In this project, it's used to organize the creation of validation rules in a scalable manner.
- **Factory Design Pattern**: Used complementarily to separate the validation logic in the Controller from the View manipulation, promoting a more organized architecture. However, it is not the main focus of the project.
- **JavaScript**: Used for the overall structure and logic of the project.


---

## üöÄ Principais pontos do Projeto
- ‚úÖ Valida√ß√£o em tempo real com Proxy.
- ‚úÖ Padr√£o de projeto Builder, utilizado em libs como [Zod](https://zod.dev/) e [Yup](https://www.npmjs.com/package/yup).

## üöÄ Key Highlights of the Project
- ‚úÖ Real-time validation using Proxy.
- ‚úÖ Builder design pattern, used in libraries like [Zod](https://zod.dev/) and [Yup](https://www.npmjs.com/package/yup).

---

## üìÅ Estrutura Sugerida (Opcional) / Suggested Structure (Optional)

```bash
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ styles.css
‚îú‚îÄ‚îÄ main.js
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ controller.js
‚îÇ   ‚îú‚îÄ‚îÄ factory.js
‚îÇ   ‚îú‚îÄ‚îÄ helpers.js
‚îÇ   ‚îú‚îÄ‚îÄ schema.js
‚îÇ   ‚îú‚îÄ‚îÄ validator.js
‚îÇ   ‚îî‚îÄ‚îÄ view.js
‚îî‚îÄ‚îÄ README.md
```

--- 

## üèóÔ∏è Arquitetura: Padr√£o de Projeto Builder
A l√≥gica de valida√ß√£o neste projeto segue o padr√£o de projeto Builder, facilitando a cria√ß√£o de regras complexas por meio da composi√ß√£o de m√©todos encadeados.

### üë∑ Como o padr√£o Builder √© aplicado
- O Builder permite construir objetos de valida√ß√£o de forma declarativa e fluida:
```js
    v.string().required()
```
- Cada m√©todo (string(), required(), etc.) representa um passo na constru√ß√£o da regra, tornando o c√≥digo mais **modular**, **leg√≠vel** e **extens√≠vel**.
- Essa abordagem substitui fun√ß√µes monol√≠ticas por pequenos blocos reutiliz√°veis, que podem ser combinados de maneira flex√≠vel conforme a necessidade de valida√ß√£o.

## üèóÔ∏è Architecture: Builder Design Pattern
The validation logic in this project follows the Builder design pattern, facilitating the creation of complex rules through the composition of chained methods.

### üë∑ How the Builder Pattern is Applied
- The Builder allows constructing validation objects in a declarative and fluent way:
```js
    v.string().required()
```
- Each method (string(), required(), etc.) represents a step in building the rule, making the code more **modular**, **readable**, and **extensible**.
- This approach replaces monolithic functions with small, reusable blocks that can be flexibly combined based on validation needs.


### üß± Exemplo de implementa√ß√£o / üß± Implementation example

```js
// validator.js
export class ValidatorBuilder {
    rules = [];

    string() {
        // simple string validation function
        const validString = (value) => (typeof value === 'string') || 'Deve ser uma string'

        // add function to rules
        this.rules.push(validString);
        
        return this;
    }

    number() {
        // simple number validation function
        const validNumber = (value) => !Number(isNaN(Number(value))) || 'Deve ser um n√∫mero'

        // add function to rules
        this.rules.push(validNumber);

        return this;
    }

    required() {
        // simple required validation function
        const validRequired = (value) => (value !== undefined && value !== null && value !== '') || 'Campo obrigat√≥rio'
        
        // add function as priority to rules
        this.rules.unshift(validRequired);

        return this;
    }

    validate(value) {
        for (const rule of this.rules) {
            const result = rule(value);
            if (result !== true) return result;
        }
        return true;
    }
}

// Instantiate each method individually and export
export const v = {
    string: () => new ValidatorBuilder().string(),
    number: () => new ValidatorBuilder().number(),
    required: () => new ValidatorBuilder().required(),
}

// v.string().required()
```

---

## üåê *Proxy: Por que usar esse interceptador?*
O Proxy em JavaScript atua como um intermedi√°rio entre o c√≥digo e o objeto-alvo, permitindo interceptar e redefinir comportamentos padr√£o de opera√ß√µes como leitura, escrita, verifica√ß√£o e exclus√£o de propriedades. Isso torna poss√≠vel adicionar l√≥gica personalizada a intera√ß√µes comuns com objetos, como valida√ß√£o, logging, formata√ß√£o ou controle de acesso.

Um Proxy √© criado a partir de dois par√¢metros: o objeto-alvo, que √© o objeto original que se deseja monitorar ou proteger, e o handler, um objeto que define fun√ß√µes especiais chamadas de traps. Essas traps funcionam como interceptadores, permitindo capturar e redefinir opera√ß√µes espec√≠ficas feitas no objeto.

As traps mais comuns usadas em Proxy s√£o:

| Trap             | Intercepta...                                |
|------------------|----------------------------------------------|
| `get`            | Leitura de propriedade (`obj.prop`)          |
| `set`            | Escrita de propriedade (`obj.prop = val`)    |
| `has`            | Verifica√ß√£o de exist√™ncia (`'prop' in obj`)  |
| `deleteProperty` | Exclus√£o de propriedade (`delete obj.prop`)  |
| `ownKeys`        | Listagem de propriedades (`Object.keys(obj)`)|

Essas traps fornecem controle total sobre como as propriedades de um objeto s√£o acessadas ou modificadas, permitindo comportamentos como a simula√ß√£o de propriedades din√¢micas, prote√ß√£o contra altera√ß√µes indesejadas, e atualiza√ß√£o autom√°tica de interfaces com base em mudan√ßas no estado do objeto.

## üåê *Proxy: Why Use This Interceptor?*
The Proxy in JavaScript acts as an intermediary between the code and the target object, allowing interception and redefinition of default behaviors for operations such as reading, writing, checking, and deleting properties. This makes it possible to add custom logic to common object interactions, such as validation, logging, formatting, or access control.

A Proxy is created using two parameters: the target object, which is the original object you want to monitor or protect, and the handler, an object that defines special functions called traps. These traps work as interceptors, enabling the capture and redefinition of specific operations performed on the object.

The most commonly used traps in a Proxy are:

| Trap             | Intercepts...                                |
|------------------|----------------------------------------------|
| `get`            | Property read (`obj.prop`)                   |
| `set`            | Property write (`obj.prop = val`)            |
| `has`            | Property existence check (`'prop' in obj`)   |
| `deleteProperty` | Property deletion (`delete obj.prop`)        |
| `ownKeys`        | 	Property listing (`Object.keys(obj)`)       |

These traps provide full control over how an object's properties are accessed or modified, enabling behaviors such as dynamic property simulation, protection against unwanted changes, and automatic interface updates based on changes in the object‚Äôs state.

### **Vantagens de usar Proxy:**

1. **Controle sobre opera√ß√µes**: Permite interceptar a√ß√µes como leitura, escrita, exclus√£o e verifica√ß√£o de propriedades em objetos, oferecendo total controle sobre como eles se comportam.
2. **Valida√ß√£o centralizada**: Toda a l√≥gica de valida√ß√£o pode ser concentrada no Proxy, evitando repeti√ß√£o de c√≥digo e mantendo o comportamento consistente em toda a aplica√ß√£o.
3. **Reatividade e observabilidade**: √â poss√≠vel reagir automaticamente a altera√ß√µes em propriedades, facilitando a implementa√ß√£o de comportamentos reativos (como atualiza√ß√£o de UI com base em dados).
4. **Simula√ß√£o de propriedades din√¢micas**: Propriedades que n√£o existem no objeto original podem ser simuladas ou calculadas sob demanda, mais flex√≠vel e inteligente.

### **Advantages of Using Proxy**

1. **Operation control**: Allows interception of actions such as reading, writing, deleting, and checking properties in objects, providing full control over how they behave.  
2. **Centralized validation**: All validation logic can be concentrated inside the Proxy, avoiding code duplication and maintaining consistent behavior throughout the application.  
3. **Reactivity and observability**: Enables automatic reactions to property changes, facilitating the implementation of reactive behaviors (such as updating the UI based on data changes).  
4. **Dynamic property simulation**: Properties that don't exist in the original object can be simulated or computed on demand, making the system more flexible and intelligent.

### üß± **Exemplo pr√°tico no projeto:**

No helper, existe uma fun√ß√£o que utiliza o Proxy para interceptar opera√ß√µes sobre um objeto com informa√ß√µes do usu√°rio, realizando valida√ß√µes com base em um esquema predefinido.

O Proxy √© configurado com um handler personalizado, que define uma fun√ß√£o set. Essa fun√ß√£o substitui a atribui√ß√£o normal de propriedades, permitindo executar l√≥gica personalizada sempre que um valor √© atribu√≠do ao objeto.

Sempre que uma propriedade (como name ou age) recebe um valor:
  
- O handler set intercepta a opera√ß√£o.
- Se o valor for v√°lido conforme o esquema, ele √© salvo no objeto data.
- Se o valor for inv√°lido, ele √© armazenado no objeto errors, junto com a mensagem de erro.

Dessa forma, o objeto original do usu√°rio atua como uma interface din√¢mica, que direciona os dados para data ou errors de acordo com as regras de valida√ß√£o, sem alterar diretamente o objeto original.

### üß± **Practical Example in the Project:**

In the helper, there is a function that uses a Proxy to intercept operations on an object containing user information, performing validations based on a predefined schema.

The Proxy is configured with a custom handler that defines a `set` function. This function replaces the default property assignment behavior, allowing custom logic to run whenever a value is assigned to the object.

Whenever a property (such as `name` or `age`) receives a value:

- The `set` handler intercepts the operation.
- If the value is valid according to the schema, it is stored in the `data` object.
- If the value is invalid, it is stored in the `errors` object along with an error message.

This way, the original user object acts as a dynamic interface that routes values to either `data` or `errors` according to the validation rules, without directly modifying the original object.


```js
// helpers.js
export function validatedProxy(schema, initialData = {}) {
    const objTarget = {
        data: {},
        errors: {}
    }
    
    const handler = {
        // SET -> Assignment interceptor, called when a value is assigned using obj[prop] = value
        // On success, returns true
        // On failure (invalid value), returns false
        set(target, prop, value) {

            // Retrieves the validation rule from the schema based on the property
            const validator = schema[prop];

            // If the field is not defined in the validator, ignore it (skip assignment, just return true)
            if (!validator) return false;

            const result = validator.validate(value);

            // If the field is invalid, remove it from `data` and store the error message
            if (result !== true) {
                Reflect.deleteProperty(target.data, prop);
                target.errors[prop] = result
                return true
            } else {
                Reflect.deleteProperty(target.errors, prop);
            };

            // If the property is valid and defined in the schema, assign the value
            target.data[prop] = value;
            return true;
        },

        // GET -> Intercepts property access (e.g., obj[prop]), simply returns the value
        get(target, prop) {
            return target[prop];
        }
    }

    const proxy = new Proxy(objTarget, handler);

    // Iterates over the properties (or keys) of the schema object
    for(const key in schema){
        // Assigns initial values to the Proxy using the data provided, which triggers the SET handler
        proxy[key] = initialData[key]
    }

    // Return created object Proxy
    return proxy
}
```

---

## üöÄ Inicializar
### Passo 1: Instalar o Visual Studio Code
- Baixe e instale o [Visual Studio Code](https://code.visualstudio.com/).

### Passo 2: Instalar a Extens√£o Live Server
- Abra o VS Code e v√° para a aba **Extens√µes** (`Ctrl+Shift+X`).
- Procure por **Live Server** e instale a extens√£o de **Ritwick Dey**.

### Passo 3: Abrir o Projeto
- Abra a pasta do projeto no VS Code (`File > Open Folder...`).

### Passo 4: Iniciar o Live Server
- Clique com o bot√£o direito no arquivo `index.html` (ou arquivo de entrada) e selecione **Open with Live Server**.

### Passo 5: Parar o Live Server
- Para parar o servidor, clique no √≠cone de **parada** no canto inferior direito do VS Code.

Pronto! O projeto estar√° rodando no seu navegador com atualiza√ß√µes autom√°ticas.

Open with Live Server

## üöÄ Initialize

### Step 1: Install Visual Studio Code
- Download and install [Visual Studio Code](https://code.visualstudio.com/).

### Step 2: Install the Live Server Extension
- Open VS Code and go to the **Extensions** tab (`Ctrl+Shift+X`).
- Search for **Live Server** and install the extension by **Ritwick Dey**.

### Step 3: Open the Project
- Open the project folder in VS Code (`File > Open Folder...`).

### Step 4: Start the Live Server
- Right-click on the `index.html` file (or entry file) and select **Open with Live Server**.

### Step 5: Stop the Live Server
- To stop the server, click the **stop** icon in the bottom-right corner of VS Code.

Done! The project will be running in your browser with automatic updates.

## üîó **Link √ötil** / **Useful Link**
- [MDN - Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
- [Design Pattern Builder - GURU](https://refactoring.guru/design-patterns/builder)
